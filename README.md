# Vernon Museum and Archives Exhibit Website

## Developer Environment Setup

First, create a `.env` file at the top level. It should include a line,

```
DATABASE_URL="file:./dev.db"
```

You will also need to create a `.env.local` file that looks like this:

```
JWT_SECRET="someSecretString"
SALT_ROUNDS=2
```

Next, run

```
$ yarn install
```

and finally,

```
$ yarn run dev
```

# API Documentation

## Authentication

The API is primarily meant for the Museum's administrative website, so most of the API endpoints require authentication. Authentication is via cookies; each cookie has the key `token` and the value is an encrypted JSON Web Token that includes the user's email address as the payload. This way, the user can be both authenticated and identified with the cookie.

### Authenticate a User

In order to get such a cookie from the API, send a request to `/api/authenticate`, and include a JSON body that includes the user's `email` and `password` (unhashed). E.g.,

```
    const response = await fetch(
      "/api/user/authenticate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
            email: "rinkyDinkValtruvian@gmail.com", 
            password: "killBinkyBong"
        })
    });
```

-   If the credentials are correct, you will get a response of `200`, a header to set the `token` cookie, and a body that includes the `UserData` (i.e., the user's information except for their password). 
-   Otherwise, it will send back a 4XX status code and an `ErrorMessage` in the body.

### Verify a User's Authenticity

If you want to verify a pre-existing cookie, you can send a request to the `/api/authenticate` endpoint:

```
const response: Response = await fetch("/api/user/authentic");
```

-   If the user is authenticated, the response will have a status of 200 and the body will include a `UserData` object. 
-   If the user is *not* authenticated, the response have a status of 4XX and the body will include an `ErrorMessage` object.

## Exhibits

Exhibits represent the actual exhibits that guest users will browse and view, and that the administrative users will create and publish. 

***this section is incomplete***

# Reading the Source Code

## Database

The database is running on SQLite3, and we interface with it via the <a href="https://www.prisma.io/">Prisma ORM</a>. The `/prisma` directory has all of the database files, and you can directly interact with the database via

```
$ sqlite3 prisma/dev.db
```

To view the structure of the database, refer to the `/prisma/schema.prisma` file.

## API Source Code Structure

All API endpoints are located in `/handlers`, and then imported to respective files in `/pages/api` so that NextJS can use it's file-based routing.

Each handler is written in a file that represents the endpoint, i.e., `/handlers/exhibit/get.ts` corresponds to `GET /api/exhibit`. A directory within `/handlers` follows the general pattern:

-   `get.ts` (or `post.ts`, `put.ts`, etc.):
    -   These files are named after HTTP methods and each one exports a single `NextApiHandler` that handles that request.
-   `index.ts`
    -   This file is where each of the `NextApiHandlers` are given middleware and aggregated into a single `NextApiHandler`. (handlers are aggregated by the `/handlers/aggregateHandlers.ts` function).

### Middleware

The `/handlers/middleware` folder is special, because it's exports include functions that take a `NextApiHandler` and wrap it in a new `NextApiHandler` that handles something with the request. 

Middleware may or may not invoke the handler you give it, depending on the request. E.g., the `withAuth` middleware follows the structure:

```
function withAuth(next: NextApiHandler): NextApiHandler {

    return async function(req, res) {

        // logic to determine if the request is authentic

        if (authentic) {
            next(req, res);
        } else {
            res.send(401);
        }
    }
}
```

## Types

Many types related to the database are automatically generated by Prisma. Additionally, the Zod library is used for runtime type-checking, which is used extentensively to verify API requests/responses.

All custom types are defined in `/types`. The `/types/specialModels.ts` file includes types that are based on the types generated by Prisma. E.g., `UserData` represents the `User` model in the database, but without the password.

`/types/general.ts` just include some types that aren't included in the database. E.g., `ErrorMessage`.